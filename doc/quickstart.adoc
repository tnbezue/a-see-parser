
== Quick Start
If you a familiar with PEG grammars, the table below shows PEG predicates
and the equivalent A-SEE-PARSER macro.


.PEG and A-SEE-PARSER
[width="100%",cols="^3,^6,10",options="header"]
|=========================================================
|PEG |A-SEE-PARSER |Comments
| . | ANY | Matches any character
| "characters" | SEQUENCE("characters")| Matches a sequence of characters
| \'c'|NEXT_CHR_IS(\'c')| match a single character. Can also use SEQUENCE("c")
|[characters] | RANGE("characters")| Matches one of specified characters
|[^characters] | RANGE("^characters")| Does not match one of the specified characters
| < text > | CAPTURE_ON text CAPTURE_OFF| Marks beginning and end of text to capture
| yytext | CAPTURED_TEXT | Captured text
| element ? | OPTIONAL(element) | optional element
| element + | ONE_OR_MORE(element) | Matches one or more elements
| element * | ZERO_OR_MORE(element) | Matches zero or more elements
| &element | NON_CONSUMMING(element) | Matches element but does not consume input
| !element | NOT(element) | Matches if not element. No input is consumed
| !\'c'| NOT_CHR(\'c')| Special case of single character. Can use NOT(NEXT_CHR_IS(\'c\')) if desired
| !. | !ANY | Matches end of input
| &{ expression } | ( expression ) | If expression is true, rule continues
| sequence { action } | RULE(sequence,action,) | C code to be executed if seqeunce is matched successfully
| A B C / X Y Z | RULE(A && B && C,,) \|\| RULE(X && Y && Z,,)|
|=========================================================

.Examples

Shell comment
[source,c]
---------------
#define EOL NEXT_CHR_IS('\n')
#define SHELL_COMMENT (NEXT_CHR_IS('#') && ZERO_OR_MORE(!EOL && ANY,,) && EOL)
---------------

C comment -- allows for nexted comments
[source,c]
---------------
#define C_COMMENT_START SEQUENCE("/*")
#define C_COMMENT_END  SEQUENCE("*/")
int nested_c_comment()
{
  return RULE(C_COMMENT_START &&
      ZERO_OR_MORE(!C_COMMENT_END && OPTIONAL(nested_c_comment()) && ANY) && C_COMMENT_END,,);
}
---------------

Capturing text
[source,c]
---------------
#define INTEGER CAPTURE_ON && RULE(ZERO_OR_MORE(RANGE("0-9"),,) && CAPTURE_OFF && !RANGE("_a-zA-Z"),,)
char* name = malloc(CAPTURE_LENGTH+1);
CAPTURE_TEXT(name,CAPTURE_LENGTH+1);
---------------

[source,c]
---------------
Identifiers and keywords

#define ID_ALPHA RANGE("_a-zA-Z")
#define ID_ALNUM RANGE("_a-zA-Z0-9")
#define IDENT RULE(ID_ALPHA && ZERO_OR_MORE(ID_ALNUM,,),,)
#define SPACING ZERO_OR_MORE(RANGE(" \t\r\n"))
#define KEYWORD(word) RULE(SEQUENCE(word) && !ID_ALNUM && SPACING)
#define IF KEYWORD("if")
#define FOR KEYWORD("for")
#define WHILE KEYWORD("while")
------

Action
[source,c]
---------------
// variable = value
char id[128];
char number_string[128];
#define EQUAL NEXT_CHR_IS('=')
RULE(CAPTURE_ON && IDENT && CAPTURE_OFF && (CAPTURE_TEXT(id,128),1) && EQUAL
      && CAPTURE_ON && INTEGER && CAPTURE_OFF,
      // Action
        int* pint = symbol_lookup(id);
        if(pint) {
          CAPTURE_TEXT(number_string,128);
          *pint = atoi(number_string);
        } else {
          fprintf(stderr,"Unknown identifier %s\n",id);
          exit(0);
        }
      , //
      )
---------------
